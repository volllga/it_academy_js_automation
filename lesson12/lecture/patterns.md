ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ:
Паттерны предназначены для решения типичных задач, возникающих в ходе проектирования. 
Любой паттерн описывает задачу, которая снова и снова возникает в нашей работе, а также принцип ее решения, 
причем таким образом, что это решение можно потом использовать миллион раз, ничего не изобретая заново.
Все паттерны обеспечивают возможность изменения некоторой части системы независимо от других частей.
-- Паттерн — решение задачи в контексте.
Не самое понятное определение, вы не находите? Не беспокойтесь, мы разберем все его составляющие — все эти контексты, задачи и решения:
- Контекстом называется ситуация, в которой применяется паттерн. Ситуация должна быть достаточно типичной и распространенной.
- Задачей называется цель, которой вы хотите добиться в контексте, в совокупности со всеми ограничениями, присущими контексту.
- Решением называется обобщенная архитектура, которая достигает заданной цели при соблюдении набора ограничений. 
- Решение должно быть возможно применять снова и снова.

В общем случае паттерн состоит из четырех основных элементов:
1. Имя. Сославшись на него, мы можем сразу описать проблему проектировакния, ее решения и их последствия. 
2. Присваивание паттернам имен позволяет проектировать на более высоком уровне абстракции. 
3. С помощью словаря паттернов можно вести обсуждение с коллегами, упоминать паттерны в документации, в тонкостях представлять дизайн системы. 
4. Нахождение хороших имен было одной из самых трудных задач при составлении каталога.
5. Задача. Описание того, когда следует применять паттерн. Необходимо сформулировать задачу и ее контекст. 
6. Может описываться конкретная проблема проектирования, например способ представления алгоритмов в виде объектов. 
7. Иногда отмечается, какие структуры классов или объектов свидетельствуют о негибком дизайне. 
8. Также может включаться перечень условий, при выполнении которых имеет смысл применять данный паттерн.
9. Решение. Описание элементов дизайна, отношений между ними, функций каждого элемента. 
10. Конкретный дизайн или реализация не имеются в виду, поскольку паттерн – это шаблон, 
11. применимый в самых разных ситуациях. Просто дается абстрактное описание задачи проектирования и того, 
12. как она может быть решена с помощью некоего весьма обобщенного сочетания элементов (в нашем случае классов и объектов).
13. Результаты – это следствия применения паттерна и разного рода компромиссы. Хотя при описании 
14. проектных решений о последствиях часто не упоминают, знать о них необходимо, 
15. чтобы можно было выбрать между различными вариантами и оценить преимущества и недостатки данного паттерна. 
16. Здесь речь идет и о выборе языка и реализации. Поскольку в объектно-ориентированном проектировании 
17. повторное использование зачастую является важным фактором, то к результатам следует относить и влияние на степень гибкости, 
18. расширяемости и переносимости системы. Перечисление всех последствий поможет вам понять и оценить их роль.



I. ПОРОЖДАЮЩИЕ ПАТТЕРНЫ
1. Паттерн ФАБРИКА (фабричный метод) - когда нужно создавать объекты. 
 Инкапсулируем подробности создания объектов. Определяет интерфейс для создания объектов. 
Придает независимость классу от конкретных объектов. 
Порождающий шаблон проектирования, предоставляющий подклассам интерфейс для создания экземпляров некоторого класса. 
В момент создания наследники могут определить, какой класс создавать. Иными словами, данный шаблон делегирует создание объектов наследникам родительского класса.

2. Паттерн ОДИНОЧКА - когда нужно чтобы класс имел только один экземпляр (при повторном создании экземпляра возвращает созданный изначально). 
Полезно если нужно, например, обеспечить подключение к базе данных (чтобы не создавать более 1 подключения). 
Порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.

3. Паттерн ПРОТОТИП - описывает виды создаваемых объектов с помощью прототипа и создает новые объекты путем его копирования.
4. Паттерн СТРОИТЕЛЬ (композиционный конструктор обьекта) - это порождающий паттерн проектирования, который позволяет создавать сложные объекты пошагово. 
 Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.
   Применение: когда нужно создавать сложные обьекты со множеством изменяющихся параметров, либо когда код должен создавать разные представления какого-то объекта. 
В этом случае есть три варианта:
    - огромный конструктор(фабрика) со множеством if/else в котором легко запуться и тяжело понять
    - плодить кучу подклассов для всех вариантов (это наверное еще хуже первого варианта)
    - паттерн строитель (предлагает разбить процесс конструирования объекта на отдельные шаги (например, построитьСтены, вставитьДвери и другие). 
   Чтобы создать объект, вам нужно поочерёдно вызывать методы строителя. Строителей может быть несколько разных вариантов, но у них общий интерфейс.)

5. Паттерн ПРОТОТИП - это порождающий паттерн проектирования, который позволяет копировать (клонировать) объекты, не вдаваясь в подробности их реализации. 
В JS для этих целей есть встроенная функция Object.create(proto[, propertiesObject]), которая фактически представляет собой паттерн прототип.


II. СТРУКТУРНЫЕ ПАТТЕРНЫ
1. Паттерн ДЕКОРАТОР (обертка) - когда нужно расширить возможности объекта без внесения изменений в его класс. Обертка вокруг объекта. 
Это структурный паттерн проектирования, который позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки». 
Т.е. происходит замена наследования композицией. Это когда один объект содержит ссылку на другой и делегирует ему работу, вместо того чтобы самому наследовать его поведение.

2. Паттерн АДАПТЕР - когда нужно использовать класс, интерфейс которого не соответствует остальному коду приложения. 
Преобразует интерфейс класса в некоторый другой интерфейс. Это структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе.

3. Паттерн ЗАМЕСТИТЕЛЬ - Подменяет другой объект для контроля доступа к нему. 
В общем смысле это обертка на подобие декоратора, но со специфическими функциями (управление доступом, логирование, кэширование и т.п.). 
Подробнее смотри в отдельной странице lepton о данном паттерне. При этом обращение идет всегда к заместителю.
В этом и смысл отделить определенный объект от прямого обращения к нему. Предоставляет суррогатный объект, управляющий доступом к другому объекту. 
В общем смысле это обертка на подобие декоратора, но со специфическими функциями (управление доступом, логирование, кэширование и т.п.). 
Подробнее смотри в отедльной странице lepton о данном паттерне. При этом обращение идет всегда к заместителю. 
В этом и смысл отделить определенный объект от прямого обращения к нему.

4. Паттерн КОМПОНОВЩИК - когда нужно сгруппировать множество объектов в древовидную структуру, а затем работать с ней так, как будто это единичный объект. 
Шаблон Компоновщик позволяет единообразно обрабатывать отдельные объекты и их группы. Он работает с иерархией «часть-целое».
Это структурный паттерн проектирования, который позволяет сгруппировать множество объектов в древовидную структуру, а затем работать с ней так, как будто это единичный объект. 
Шаблон Компоновщик позволяет единообразно обрабатывать отдельные объекты и их группы. Он работает с иерархией «часть-целое»

5. Паттерн МОСТ - отделяет абстракцию от реализации, благодаря чему появляется возможность независимо изменять то и другое. 
Это структурный паттерн проектирования, который разделяет один или несколько классов на две отдельные иерархии — 
абстракцию и реализацию, позволяя изменять их независимо друг от друга.
   Например у нас есть класс Круг, и мы хотим создавать круги разного цвета, для этого нужно будет создать подклассы Синий Круг, Желтый круг и т.д. 
А если потом появятся квадраты и треугольники, то для них тоже нужно будет создавать большое количество подклассов. 
В итоге иерархия будет огромной. Логичнее создать две независимых иерархии - Формы (круг, квадрат, треугольник) и Цвета (синий, желтый и т.д.) и потом соединить их композицией.

6. Паттерн ФАСАД - когда нужен простой интерфейс к сложной подсистеме классов, фреймворку или библиотеке. 
Это структурный паттерн проектирования, который предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку.

7. Паттерн ПРИСПОСОБЛЕНЕЦ - структурный шаблон проектирования, при котором объект, 
представляющий себя как уникальный экземпляр в разных местах программы, по факту не является таковым (типа синглтон для обьектов-элементов массива приспособленца).

III. ПОВЕДЕНЧЕСКИЕ ПАТТЕРНЫ
1. Паттерн НАБЛЮДАТЕЛЬ (почтальон) - когда нужно отслеживать изменения чего-либо (работает как события в JS). При изменении состояния одного объекта (Субьекта) происходит автоматическое оповещение и обновление всех зависимых объектов (наблюдателей). Объекты получаются слабо связанными
2. Паттерн СТРАТЕГИЯ (стратегия выбора реализации) - отделение процедуры выбора алгоритма от его реализации. Когда нужно отделить постоянное от изменчивого. Определяет семейство алгоритмов, инкапсулируя их все и позволяя подставлять один вместо другого.
3. Паттерн КОМАНДА - когда нужно отделить объект-источник запроса от объекта, принимающего и выполняющего эти запросы. Когда нужна операция отмены, повтора действия или создание очереди. Это поведенческий паттерн проектирования, который превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их, а также поддерживать отмену операций.
   Убирает прямую зависимость между объектами, вызывающими операции, и объектами, которые их непосредственно выполняют.
   Позволяет реализовать простую отмену и повтор операций.
   Позволяет реализовать отложенный запуск операций.
   Позволяет собирать сложные команды из простых.
   Реализует принцип открытости/закрытости.
4. Паттерн ШАБЛОННЫЙ МЕТОД - задает «скелет» алгоритма в методе, оставляя определение реализации некоторых шагов субклассам. Субклассы могут переопределять некоторые части алгоритма без изменения его структуры. Когда подклассы должны расширять базовый алгоритм, не меняя его структуры. Когда у вас есть несколько классов, делающих одно и то же с незначительными отличиями. 
Если вы редактируете один класс, то приходится вносить такие же правки и в остальные классы.
5. Паттерн ИТЕРАТОР - когда имеется объект, содержащий совокупность данных. Эти данные могут храниться в виде сложной структуры, а вам необходимо обеспечить удобный доступ к каждому элементу этой структуры. Пользователи вашего объекта не обязаны знать, как организованы ваши данные, – им необходим доступ к отдельным элементам. Это поведенческий паттерн проектирования, который даёт возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления.
6. Паттерн СОСТОЯНИЕ - когда нужно чтобы программа по разному реагировала на одни и теже события в зависимости от своего внутреннего состояния. Состояние может меняться (задаваться вручную или сменяться последовательно(как итерации в цикле)). Управляет изменением поведения объекта при изменении его внутреннего состояния. Внешне это выглядит так, словно объект меняет свой класс.
   Основная идея в том, что программа может находиться в одном из нескольких состояний, которые всё время сменяют друг друга.
   Находясь в разных состояниях, программа может по-разному реагировать на одни и те же события, которые происходят с ней.
   Набор этих состояний, а также переходов между ними, предопределён и конечен (хотя теоретически можно и добавить тут динамики).
7. Паттерн ЦЕПОЧКА ОБЯЗАННОСТЕЙ - это поведенческий паттерн проектирования, который позволяет передавать запросы последовательно по цепочке обработчиков. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи. С помощью данного паттерна можно избежать жесткой зависимости отправителя запроса от его получателя.
8. Паттерн МЕДИАТОР (посредник) - определяет объект, в котором инкапсулировано знание о том, как взаимодействуют объекты из некоторого множества.
9. Паттерн ХРАНИТЕЛЬ (memento) - Позволяет, не нарушая инкапсуляции, получить и сохранить во внешней памяти внутреннее состояние объекта, чтобы позже объект можно было восстановить точно в таком же состоянии.
10. Паттерн ПОСЕТИТЕЛЬ - используется для расширения возможностей комбинации объектов. Когда вам нужно выполнить какую-то операцию над всеми элементами сложной структуры объектов, например, деревом. Посетитель позволяет применять одну и ту же операцию к объектам различных классов. ИЛИ когда новое поведение имеет смысл только для некоторых классов из существующей иерархии.
11. Паттерн ПОСРЕДНИК (Mediator) - это поведенческий паттерн проектирования, который позволяет уменьшить связанность множества классов между собой, благодаря перемещению этих связей в один класс-посредник.
12. Паттерн ИНТЕРПРЕТАТОР - 



